// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/// @title EncryptedVoting - Anonymous Governance (PIP-0012)
/// @notice FHE-encrypted ballots with homomorphic tallying.
///         Individual votes are never decrypted. Voter identity is
///         mathematically unlinkable to any ballot. Coercion-resistant
///         via deniable ballots -- voters under duress cannot prove their vote.
/// @dev FHE operations are pseudocode; real deployment uses luxfi/fhe precompiles.
contract EncryptedVoting is Ownable, ReentrancyGuard {

    enum ProposalState { Setup, Voting, Tallying, Finalized, Cancelled }

    struct Proposal {
        bytes32 descriptionHash;   // Poseidon2(proposal_text)
        bytes32 encryptionKey;     // Threshold FHE public key for this election
        bytes32 encryptedTallyFor; // FHE: Enc(sum_of_for_votes)
        bytes32 encryptedTallyAgainst; // FHE: Enc(sum_of_against_votes)
        ProposalState state;
        uint64  votingStart;
        uint64  votingEnd;
        uint256 ballotCount;
        uint256 finalFor;          // Populated only after threshold decryption
        uint256 finalAgainst;
    }

    uint256 public proposalCount;

    /// @notice proposalId => Proposal
    mapping(uint256 => Proposal) public proposals;

    /// @notice Nullifier set: Poseidon2(voter_secret, proposalId) => used
    ///         Prevents double voting without linking voter to ballot.
    mapping(bytes32 => bool) public nullifiers;

    event ProposalCreated(uint256 indexed proposalId, uint64 votingStart, uint64 votingEnd);
    event BallotCast(uint256 indexed proposalId, uint256 ballotIndex);
    event TallyFinalized(uint256 indexed proposalId, uint256 totalFor, uint256 totalAgainst);

    constructor() Ownable(msg.sender) {}

    /// @notice Create a new encrypted proposal.
    /// @param descriptionHash  Poseidon2(proposal_text)
    /// @param encryptionKey    Threshold FHE public key (generated by voting committee)
    /// @param votingStart      Unix timestamp when voting opens
    /// @param votingEnd        Unix timestamp when voting closes
    function createProposal(
        bytes32 descriptionHash,
        bytes32 encryptionKey,
        uint64 votingStart,
        uint64 votingEnd
    ) external onlyOwner returns (uint256 proposalId) {
        require(votingEnd > votingStart, "Voting: invalid window");

        proposalId = proposalCount++;

        // FHE: Initialize tallies as encryptions of zero
        //       encryptedTallyFor = tFHE.encrypt(0, encryptionKey)
        //       encryptedTallyAgainst = tFHE.encrypt(0, encryptionKey)
        bytes32 encZero = keccak256(abi.encodePacked(encryptionKey, uint256(0)));

        proposals[proposalId] = Proposal({
            descriptionHash: descriptionHash,
            encryptionKey: encryptionKey,
            encryptedTallyFor: encZero,
            encryptedTallyAgainst: encZero,
            state: ProposalState.Setup,
            votingStart: votingStart,
            votingEnd: votingEnd,
            ballotCount: 0,
            finalFor: 0,
            finalAgainst: 0
        });

        emit ProposalCreated(proposalId, votingStart, votingEnd);
    }

    /// @notice Cast an encrypted ballot. The vote value is never revealed.
    /// @param proposalId       Target proposal
    /// @param encryptedBallot  FHE.encrypt(1, pk) for "for", FHE.encrypt(0, pk) for "against"
    /// @param nullifier        Poseidon2(voter_secret, proposalId) -- unique per voter per proposal
    /// @param zkProof          ZK proof that ballot is well-formed (encrypts 0 or 1, not arbitrary)
    function castBallot(
        uint256 proposalId,
        bytes32 encryptedBallot,
        bytes32 nullifier,
        bytes calldata zkProof
    ) external nonReentrant {
        Proposal storage p = proposals[proposalId];
        require(p.state == ProposalState.Voting, "Voting: not active");
        require(block.timestamp >= p.votingStart && block.timestamp <= p.votingEnd, "Voting: outside window");
        require(!nullifiers[nullifier], "Voting: already voted");
        require(zkProof.length > 0, "Voting: missing proof");

        // FHE: Homomorphic addition -- add encrypted ballot to running tally
        //       p.encryptedTallyFor = tFHE.add(p.encryptedTallyFor, encryptedBallot)
        //       p.encryptedTallyAgainst = tFHE.add(p.encryptedTallyAgainst, tFHE.sub(enc(1), encryptedBallot))
        //
        //       COERCION RESISTANCE: Even the voter cannot prove how they voted.
        //       A deniable ballot looks identical to a real ballot. Under duress,
        //       the voter can produce a fake "receipt" that verifies but does not
        //       correspond to the actual encrypted ballot.

        nullifiers[nullifier] = true;
        p.ballotCount++;

        // Simulate homomorphic tally update
        p.encryptedTallyFor = keccak256(abi.encodePacked(p.encryptedTallyFor, encryptedBallot));

        emit BallotCast(proposalId, p.ballotCount);
    }

    /// @notice Finalize tally after threshold decryption by voting committee.
    ///         Only callable by owner (represents the threshold decryption ceremony).
    function finalizeTally(
        uint256 proposalId,
        uint256 decryptedFor,
        uint256 decryptedAgainst
    ) external onlyOwner {
        Proposal storage p = proposals[proposalId];
        require(p.state == ProposalState.Tallying, "Voting: not in tally phase");
        require(decryptedFor + decryptedAgainst == p.ballotCount, "Voting: count mismatch");

        p.finalFor = decryptedFor;
        p.finalAgainst = decryptedAgainst;
        p.state = ProposalState.Finalized;

        emit TallyFinalized(proposalId, decryptedFor, decryptedAgainst);
    }

    /// @notice Transition proposal state. Only forward transitions allowed.
    function advanceState(uint256 proposalId) external onlyOwner {
        Proposal storage p = proposals[proposalId];
        if (p.state == ProposalState.Setup && block.timestamp >= p.votingStart) {
            p.state = ProposalState.Voting;
        } else if (p.state == ProposalState.Voting && block.timestamp > p.votingEnd) {
            p.state = ProposalState.Tallying;
        }
    }
}
